---
# roles/k8s-worker/tasks/main.yml

- name: Check if running on Fedora
  ansible.builtin.fail:
    msg: "This playbook is designed for Fedora systems only"
  when: ansible_distribution != "Fedora"

- name: Update system packages
  ansible.builtin.dnf:
    name: "*"
    state: latest

- name: Install system dependencies and SELinux packages
  ansible.builtin.dnf:
    name:
      - bridge-utils
      - iproute-tc
      - iptables
      - curl
      - gnupg
      - python3-libselinux
      - python3-policycoreutils
    state: present

- name: Configure SELinux to permissive mode
  ansible.posix.selinux:
    policy: targeted
    state: permissive
  register: selinux_changed

- name: Reboot if SELinux changed
  ansible.builtin.reboot:
    msg: "Rebooting due to SELinux change"
    reboot_timeout: 300
  when: selinux_changed.changed

- name: Check if Kubernetes repository exists
  ansible.builtin.stat:
    path: /etc/yum.repos.d/kubernetes.repo
  register: k8s_repo_exists

- name: Add Kubernetes repository GPG key
  ansible.builtin.rpm_key:
    key: "https://pkgs.k8s.io/core:/stable:/v{{ kubernetes_version }}/rpm/repodata/repomd.xml.key"
    state: present
  when: not k8s_repo_exists.stat.exists

- name: Add Kubernetes repository
  ansible.builtin.yum_repository:
    name: kubernetes
    description: Kubernetes Repository
    baseurl: "https://pkgs.k8s.io/core:/stable:/v{{ kubernetes_version }}/rpm/"
    enabled: yes
    gpgcheck: yes
    gpgkey: "https://pkgs.k8s.io/core:/stable:/v{{ kubernetes_version }}/rpm/repodata/repomd.xml.key"
  when: not k8s_repo_exists.stat.exists
    
- name: Install Kubernetes packages
  ansible.builtin.dnf:
    name:
      - containerd
      - kubelet
      - kubeadm
    state: present
    disable_excludes: kubernetes

- name: Configure firewall for Kubernetes worker
  ansible.posix.firewalld:
    port: "{{ item }}"
    permanent: yes
    state: enabled
    immediate: yes
  become: yes
  loop:
    - "10250/tcp"       # Kubelet API
    - "30000-32767/tcp" # NodePort Services
    - "8472/udp"        # Flannel VXLAN

- name: Disable swap permanently
  ansible.builtin.command: swapoff -a
  changed_when: false
  
- name: Remove swap from fstab
  ansible.builtin.lineinfile:
    path: /etc/fstab
    regexp: '.*swap.*'
    state: absent
    
- name: Load required kernel modules
  community.general.modprobe:
    name: "{{ item }}"
    state: present
  loop:
    - overlay
    - br_netfilter
  register: modules_loaded
  failed_when: false
  
- name: Verify kernel modules loaded
  ansible.builtin.shell: lsmod | grep {{ item }}
  loop:
    - overlay
    - br_netfilter
  register: module_check
  failed_when: module_check.rc != 0
  changed_when: false
    
- name: Configure kernel modules to load on boot
  ansible.builtin.lineinfile:
    path: /etc/modules-load.d/k8s.conf
    line: "{{ item }}"
    create: yes
    mode: '0644'
  loop:
    - overlay
    - br_netfilter
    
- name: Configure sysctl for Kubernetes
  ansible.posix.sysctl:
    name: "{{ item.name }}"
    value: "{{ item.value }}"
    state: present
    reload: yes
    sysctl_file: /etc/sysctl.d/k8s.conf
  loop:
    - { name: "net.bridge.bridge-nf-call-iptables", value: "1" }
    - { name: "net.bridge.bridge-nf-call-ip6tables", value: "1" }
    - { name: "net.ipv4.ip_forward", value: "1" }
    
- name: Check if containerd config exists
  ansible.builtin.stat:
    path: /etc/containerd/config.toml
  register: containerd_config_exists

- name: Create containerd config directory
  ansible.builtin.file:
    path: /etc/containerd
    state: directory
    mode: '0755'
  when: not containerd_config_exists.stat.exists

- name: Generate default containerd config
  ansible.builtin.shell: containerd config default > /etc/containerd/config.toml
  when: not containerd_config_exists.stat.exists
  register: containerd_config_generated

- name: Configure containerd to use systemd cgroup driver
  ansible.builtin.replace:
    path: /etc/containerd/config.toml
    regexp: 'SystemdCgroup = false'
    replace: 'SystemdCgroup = true'
  register: containerd_config_changed
    
- name: Start and enable containerd
  ansible.builtin.systemd:
    name: containerd
    state: started
    enabled: yes
    daemon_reload: yes

- name: Restart containerd if config changed
  ansible.builtin.systemd:
    name: containerd
    state: restarted
  when: containerd_config_changed.changed or containerd_config_generated.changed
  
- name: Verify containerd is running
  ansible.builtin.systemd:
    name: containerd
  register: containerd_status
  failed_when: containerd_status.status.ActiveState != "active"
    
- name: Enable kubelet service
  ansible.builtin.systemd:
    name: kubelet
    enabled: yes
    
- name: Check if node is already joined
  ansible.builtin.stat:
    path: /etc/kubernetes/kubelet.conf
  register: kubelet_conf
  
- name: Wait for join command file to be available
  ansible.builtin.wait_for:
    path: "{{ k8s_join_command_local }}"
    timeout: 300
  delegate_to: localhost
  run_once: true
  when: not kubelet_conf.stat.exists

- name: Read join command from control machine
  ansible.builtin.slurp:
    src: "{{ k8s_join_command_local }}"
  register: join_command_content
  delegate_to: localhost
  run_once: true
  when: not kubelet_conf.stat.exists
  
- name: Validate join command content
  ansible.builtin.fail:
    msg: "Join command is empty or invalid"
  when: 
    - not kubelet_conf.stat.exists
    - join_command_content is defined
    - (join_command_content.content | b64decode | trim) == ""
  
- name: Join worker node to cluster
  ansible.builtin.shell: "{{ join_command_content.content | b64decode | trim }}"
  when: 
    - not kubelet_conf.stat.exists
    - join_command_content is defined
    - join_command_content.content is defined
    - (join_command_content.content | b64decode | trim) != ""
  register: join_result
  retries: 3
  delay: 10
  until: join_result.rc == 0
  
- name: Display join result
  ansible.builtin.debug:
    msg: "Node join result: {{ join_result.stdout }}"
  when: join_result is defined and join_result.changed
  
- name: Fallback - try to read join command from master node
  ansible.builtin.slurp:
    src: "{{ k8s_join_command_file }}"
  register: join_command_remote
  delegate_to: "{{ groups['master'][0] }}"
  when: 
    - not kubelet_conf.stat.exists
    - join_command_content is not defined or join_result is failed
  
- name: Join worker node to cluster (fallback)
  ansible.builtin.shell: "{{ join_command_remote.content | b64decode | trim }}"
  when: 
    - not kubelet_conf.stat.exists
    - join_command_remote is defined
    - (join_command_remote.content | b64decode | trim) != ""
  register: join_result_fallback
  retries: 3
  delay: 10
  until: join_result_fallback.rc == 0
  
- name: Display join result (fallback)
  ansible.builtin.debug:
    msg: "Node join result: {{ join_result_fallback.stdout }}"
  when: join_result_fallback is defined and join_result_fallback.changed

- name: Verify kubelet is running after join
  ansible.builtin.systemd:
    name: kubelet
  register: kubelet_status
  when: (join_result is defined and join_result.changed) or (join_result_fallback is defined and join_result_fallback.changed)
  
- name: Cleanup join command file
  ansible.builtin.file:
    path: "{{ k8s_join_command_local }}"
    state: absent
  delegate_to: localhost
  run_once: true
  when: join_result is defined and join_result.changed